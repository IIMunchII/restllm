from enum import auto, UNIQUE, verify, StrEnum
from typing import Optional
from pydantic import BaseModel, Field

from .base import MetaModel
from .functions import FunctionCall
from .completion import CompletionParameters
from ..models.functions import get_function_schemas

@verify(UNIQUE)
class RoleTypes(StrEnum):
    USER = auto()
    SYSTEM = auto()
    ASSISTANT = auto()
    FUNCTION = auto()


@verify(UNIQUE)
class ModelTypes(StrEnum):
    GPT3_TURBO = "gpt-3.5-turbo"
    GPT3_TURBO_16K = "gpt-3.5-turbo-16k"
    GPT4 = "gpt-4"
    GPT4_32K = "gpt-4-32k"


class ChatMessage(BaseModel):
    role: RoleTypes = Field(
        description="The role of the message's author. Roles can be: system, user, assistant, or function.",
        examples=[RoleTypes.USER, RoleTypes.SYSTEM],
    )
    content: str = Field(
        description="The contents of the message. It is required for all messages, but may be null for assistant messages with function calls.",
        examples=["Can you write a function in Python that adds two numbers together?"],
    )
    name: Optional[str] = Field(
        default=None,
        max_length=64,
        pattern="^[a-zA-Z0-9_]*$",
        description="The name of the author of the message. It is required if the role is 'function'. The name should match the name of the function represented in the content. It can contain characters (a-z, A-Z, 0-9), and underscores, with a maximum length of 64 characters.",
        examples=["Alice", "AI Assistant"],
    )
    function_call: Optional[FunctionCall] = Field(
        default=None,
        description="The name and arguments of a function that should be called, as generated by the model.",
        examples=[None]
    )


class Chat(BaseModel):
    completion_parameters: CompletionParameters = Field(
        description="Set of parameters for chat completion. Check litellm docs for more detail: https://docs.litellm.ai/docs/completion/input"
    )
    messages: list[ChatMessage] = Field(
        description="A list of messages comprising the conversation so far."
    )

    def last_message_is_user(self) -> bool:
        return self.messages[-1].role == RoleTypes.USER

    def dump_json_for_completion(self) -> dict:
        completion_kwargs = self.model_dump(mode="json", exclude_none=True)
        completion_parameters: dict = completion_kwargs.pop("completion_parameters")
        completion_kwargs.update(completion_parameters)

        function_names = completion_parameters.get("functions")
        if function_names:
            function_schemas = get_function_schemas(function_names)
            completion_kwargs.update({"functions":function_schemas})
        return completion_kwargs

class ChatWithMeta(MetaModel):
    object: Chat


class ChatMessageWithMeta(MetaModel):
    object: ChatMessage
